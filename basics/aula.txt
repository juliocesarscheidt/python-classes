

# computador entende binario
0         0000
1         0001
2         0010
3         0011
4         0100
5         0101
6         0110
7         0111
8         1000
9         1001
10        1010
11        1011
12        1100
13        1101
14        1110
15        1111



# linguagens interpretadas
  Linguagem interpretada é uma linguagem de programação em que o código fonte é executado por um programa de computador chamado interpretador (ao invés de serem compiladas), onde a interpretação e a execução do programa acontecem em tempo real e independente do sistema operacional utilizado.

  Geralmente possuem um REPL (read eval print loop)

  Exemplos: javascript, python, php, ruby, shellscript

# linguagens compiladas
  Linguagem compilada é uma linguagem de programação em que o código fonte, nessa linguagem, é executado diretamente pelo sistema operacional ou pelo processador (ou alguma máquina virtual, ex. JVM do Java), após ser traduzido por meio de um processo chamado compilação, usando um programa de computador chamado compilador, para uma linguagem de baixo nível, como linguagem de montagem (assembly) ou código de máquina
  
  Exemplos: java, csharp, c, c++, golang, rust



# paradigmas
Orientação a objeto
  Modela o programa em termos de objetos, que são instâncias de classes que encapsulam dados/atributos e comportamentos/metodos
  Exemplos: csharp, java, c++, typescript
  Outras linguagens como python, php, javascript, incorporam alguns conceitos da POO

Procedural
  Organiza o programa como uma sequência de procedimentos ou rotinas.
  Exemplos: fortran, c

Funcional
  Baseia-se no conceito de funções matemáticas, evitando estados mutáveis e dados globais.
  Exemplos: haskell, lisp, scala
  Outras linguagens incorporam conceitos funcionais, como javascript, python, e até java nas versões mais atuais

Orientado a Eventos
  O programa responde a eventos gerados pelo sistema ou usuário
  Exemplos: javascript, visual basic



# base das linguagens
variaveis
  sao armazenadas em memória, e então recuperadas quando acessadas
  possuem endereço na memória
  - algumas linguagens possuem também constantes

funções/metodos - procedimentos
  encapsulam lógicas, trechos, sequencias de instruções em algo que pode ser reutilizado posteriormente



# tipos primitivos

# string
nome = "julio"
print(nome)
print(type(nome))

# int
numero = 1
print(type(numero))

# float
flutuante = 1.50
print(type(flutuante))

# bool
booleano = True
print(type(booleano))



# tipos complexos

# lista/vetor
# lista = [1, 2]
lista = list()
lista.append(1)
lista.append(2)
print(lista)
print(type(lista))

matriz = [[1, 2], [3, 4]]
print(type(matriz))

# dicionario/mapa - armazena chave e valor
# dicionario = {"chave_1": "valor_1"}
dicionario = dict()
dicionario["chave_1"]  = "valor_1"
print(type(dicionario))

# conjunto - armazena valores unicos, inordenado
# conjunto = {'a', 'b', 'c', 'd'}
conjunto = set()
conjunto.add("a")
conjunto.add("b")
print(conjunto)

# tupla - imutavel, nao pode ser alterada
# tupla_simples = 0, 1, 2
tupla_simples = (0, 1, 2)
tupla_simples = tuple()

print(tupla_simples)
print(type(tupla_simples))

tupla_um_elemento = (0,)
print(tupla_um_elemento)
print(type(tupla_um_elemento))



# operadores aritméticos
adição +                    2 + 10 = 12       (se ambos forem int, o resultado é int, senão o resultado é float)
subtração -                 8 - 2 = 6         (se ambos forem int, o resultado é int, senão o resultado é float)
multiplicação *             2 * 4 = 8         (se ambos forem int, o resultado é int, senão o resultado é float)
divisão /                   10 / 5 = 2.0      (resultado é float)
exponenciação **            4 ** 2 = 16
resto %                     5 % 2 = 1


numero1 = 15
numero2 = 20

numero1 + numero2
35



# comparadores
==                  1 == 1    => True     (compara valores)
>=                  2 >= 4    => False
<=                  2 <= 4    => True
>                   2 > 8     => False
<                   2 < 8     => True
!=                  2 != 8    => True    (compara valores)

is                  compara referência


numero1 == numero2
False

lista_a = [0, 1, 2]
lista_b = [0, 1, 2]

lista_a is lista_b
# False
lista_a == lista_b
# True



# operadores booleanos
and         E
or          OU
not         NÃO




# condicionais
SE (expressão booleana)
if                            if numero1 == numero2:
                                print("numero1 e igual ao numero2")

SE ENTÂO (expressão booleana)
elif                          elif numero1 > numero2:
                                print("numero1 e maior que o numero2")
                    
SENÂO
else                          else:
                                print("numero1 e menor que o numero2")


if numero1 == numero2:
  print("numero1 e igual ao numero2")
else:
  print("numero1 e diferente do numero2")
                                


# loops
PARA (cada elemento
for                           for i in range(0, 10):
                                print(i)

ENQUANTO
while                         i = 0
                              while i < 10:
                                print(i)
                                i += 1

# controle de fluxo
INTERROMPER
break
                              for i in range(0, 10):
                                if i == 5:
                                  break
                                else:
                                  print(i)

CONTINUAR
continue
                              for i in range(0, 10):
                                if i == 5:
                                  continue
                                else:
                                  print(i)

PASSE
pass
                              for i in range(0, 10):
                                if i == 5:
                                  pass
                                else:
                                  print(i)



# funções
def => definir função

def funcao() -> str:
    return "Hello World"

print(type(funcao))
# <class 'function'>
print(funcao())
# "Hello World"


def dizer_ola(nome: str, idade: int):
  print("ola pessoa " + nome + " de idade " + str(idade))
  print("ola pessoa {} de idade {}".format(nome, idade))
  print("ola pessoa %s de idade %d" % (nome, idade))
  print(f"ola pessoa {nome} de idade {idade}")

dizer_ola("julio", 50)
dizer_ola(nome="julio", idade=50)
# dizer_ola(idade=50, nome="julio")



# tempo = distancia / velocidade media

def calcula_tempo_entre(distancia, velocidade_media):
  tempo_em_horas = distancia / velocidade_media
  tempo_em_minutos = tempo_em_horas * 60
  minutos_resto = tempo_em_minutos % 60
  horas_exatas = tempo_em_minutos // 60
  return f"{horas_exatas} horas e {minutos_resto} minutos" \
    if \
      horas_exatas > 0 \
    else \
      f"{minutos_resto} minutos"
  

400 km, 40 km/h
print(calcula_tempo_entre(400, 40))
# 10.0 horas e 0.0 minutos

4 km, 40 km/h
print(calcula_tempo_entre(4, 40))
# 6.0 minutos

4 km, 15 km/h
print(calcula_tempo_entre(4, 15))
16.0 minutos

print(calcula_tempo_entre(4, 0))
# ZeroDivisionError: division by zero


try:
  print(10 / 0)
except ZeroDivisionError as e:
  print("Ocorreu um erro aqui =>", e)
finally:
  print("Vai cair aqui de qualquer jeito")




# modulos
from math import sqrt

print(sqrt(4))
# 2.0

# square root         16 ** (1/2) = 4
print(4 ** (1/2))








